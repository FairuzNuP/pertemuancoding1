// game.js - Blob Arena (single-file .io-like experience)
// Playable on PC & Mobile (virtual joystick + touch buttons)

// ----- Config -----
const ARENA = { w: 2000, h: 2000 };   // arena world units
const PELLET_COUNT = 500;
const BOT_COUNT = 12;
const START_MASS = 10;

// ----- Canvas & viewport -----
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
addEventListener('resize', resize);
resize();

// ----- HUD -----
const scoreEl = document.getElementById('score');
const playersEl = document.getElementById('players');

// ----- Utility -----
function rand(min, max){ return Math.random()*(max-min)+min; }
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

// convert mass -> radius (area proportional)
function massToRadius(m){ return Math.sqrt(m) * 4 + 6; }

// ----- World state -----
let camera = { x: ARENA.w/2, y: ARENA.h/2 }; // camera center in world coords

// player object
const player = {
  id: 'you',
  x: ARENA.w/2 + rand(-50,50),
  y: ARENA.h/2 + rand(-50,50),
  mass: START_MASS,
  vx:0, vy:0,
  color: '#86C232',
  isBot:false,
  alive:true,
  splitCooldown:0
};

// bots array
const bots = [];

// pellets
const pellets = [];

// other blobs (bots + player stored in same pool for convenience)
let blobs = [];

// ----- Init pellets -----
function spawnPellet(i){
  return {
    id: 'p'+i,
    x: Math.floor(rand(0, ARENA.w)),
    y: Math.floor(rand(0, ARENA.h)),
    r: 4,
    color: '#ffd37a'
  };
}

for(let i=0;i<PELLET_COUNT;i++) pellets.push(spawnPellet(i));

// ----- Init bots -----
function makeBot(i){
  return {
    id: 'bot'+i,
    x: Math.floor(rand(0, ARENA.w)),
    y: Math.floor(rand(0, ARENA.h)),
    mass: START_MASS * rand(0.8,1.6),
    vx:0, vy:0,
    color: ['#ff6b6b','#6b8cff','#9b6bff','#ffd37a'][i%4],
    isBot:true,
    alive:true,
    target: null,
    splitCooldown:0
  };
}
for(let i=0;i<BOT_COUNT;i++) bots.push(makeBot(i));

// collect into blobs list (player first)
function rebuildBlobs(){ blobs = [player].concat(bots.filter(b=>b.alive)); }
rebuildBlobs();

// ----- Input (desktop) -----
const keys = {};
addEventListener('keydown',(e)=> keys[e.key.toLowerCase()] = true);
addEventListener('keyup',(e)=> keys[e.key.toLowerCase()] = false);

// ----- Mouse pointer for direction (desktop) -----
let mouse = { x: canvas.width/2, y: canvas.height/2 };
canvas.addEventListener('mousemove', (ev)=>{
  mouse.x = ev.clientX; mouse.y = ev.clientY;
});

// ----- Mobile joystick (simple) -----
const joyBase = document.getElementById('joyBase');
const joyThumb = document.getElementById('joyThumb');
let joyTouchId = null;
let joyVec = { x:0, y:0 };
if(joyBase){
  joyBase.addEventListener('touchstart', ev=>{
    ev.preventDefault();
    const t = ev.changedTouches[0]; joyTouchId = t.identifier;
  }, {passive:false});
  joyBase.addEventListener('touchmove', ev=>{
    ev.preventDefault();
    const t = [...ev.changedTouches].find(tt=>tt.identifier===joyTouchId) || ev.changedTouches[0];
    if(!t) return;
    const rect = joyBase.getBoundingClientRect();
    const cx = rect.left + rect.width/2, cy = rect.top + rect.height/2;
    const dx = t.clientX - cx, dy = t.clientY - cy;
    const max = rect.width * 0.36;
    const ndx = Math.max(-max, Math.min(max, dx));
    const ndy = Math.max(-max, Math.min(max, dy));
    joyThumb.style.transform = `translate(${ndx}px, ${ndy}px)`;
    joyVec.x = ndx/max; joyVec.y = ndy/max;
  }, {passive:false});
  joyBase.addEventListener('touchend', ev=>{
    ev.preventDefault();
    joyTouchId = null; joyVec.x = 0; joyVec.y = 0; joyThumb.style.transform = 'translate(0,0)';
  }, {passive:false});
}

// touch buttons: Split / Eject
document.getElementById('btnSplit').addEventListener('touchstart', ev=>{ ev.preventDefault(); doSplit(player); }, {passive:false});
document.getElementById('btnEject').addEventListener('touchstart', ev=>{ ev.preventDefault(); ejectMass(player); }, {passive:false});

// desktop split (space) & eject (e)
addEventListener('keydown',(e)=>{
  if(e.code === 'Space') doSplit(player);
  if(e.key.toLowerCase()==='e') ejectMass(player);
});

// ----- Gameplay actions -----
function ejectMass(p){
  if(p.mass < 12) return;
  p.mass -= 2;
  // spawn a pellet-like ejected mass in moving direction
  const speed = 6;
  const dir = { x: p.vx || 0.001, y: p.vy || 0.001 };
  const len = Math.hypot(dir.x, dir.y);
  const nx = dir.x/len, ny = dir.y/len;
  const pellet = { id:'e'+Date.now(), x: p.x + nx*(massToRadius(p.mass)+8), y: p.y + ny*(massToRadius(p.mass)+8), r:5, color:'#fff', vx: nx*speed, vy: ny*speed, life: 3000 };
  pellets.push(pellet);
}

function doSplit(p){
  if(p.mass < 12) return;
  if(p.splitCooldown && p.splitCooldown > performance.now()) return;
  const splitMass = p.mass * 0.45;
  p.mass *= 0.55;
  const angle = rand(0, Math.PI*2);
  const child = {
    id: p.id + '_split_' + Date.now(),
    x: p.x + Math.cos(angle)*(massToRadius(p.mass)+20),
    y: p.y + Math.sin(angle)*(massToRadius(p.mass)+20),
    mass: splitMass,
    vx: Math.cos(angle)*10,
    vy: Math.sin(angle)*10,
    color: p.color,
    isBot: p.isBot,
    alive:true,
    splitCooldown: performance.now() + 1000
  };
  // for player, we just create a temporary extra blob that will merge back via simple absorb rules
  blobs.push(child);
  // set cooldown to avoid rapid split
  p.splitCooldown = performance.now() + 500;
}

// ----- Simple AI for bots -----
function updateBot(bot, dt){
  if(!bot.alive) return;
  // simple behavior: if sees smaller blob nearby, chase; else wander towards random target
  // pick target occasionally
  if(!bot.target || Math.random()<0.01){
    // look for nearest edible (pellet or smaller blob)
    let target = null; let bestScore = Infinity;
    // pellets
    for(const pe of pellets){
      const d = Math.hypot(pe.x - bot.x, pe.y - bot.y);
      if(d < bestScore){ bestScore = d; target = {type:'pellet', ref:pe}; }
    }
    // smaller blobs
    for(const other of blobs){
      if(other === bot) continue;
      if(!other.alive) continue;
      if(other.mass < bot.mass*0.9){
        const d = Math.hypot(other.x - bot.x, other.y - bot.y);
        if(d < bestScore){ bestScore = d; target = {type:'blob', ref:other}; }
      }
    }
    if(target) bot.target = target;
    else { bot.target = { type:'pos', ref:{ x: rand(0,ARENA.w), y: rand(0,ARENA.h) } }; }
  }

  // move toward target
  let tx = bot.target.ref.x, ty = bot.target.ref.y;
  if(bot.target.type === 'pellet') { tx = bot.target.ref.x; ty = bot.target.ref.y; }
  else if(bot.target.type === 'blob' && !bot.target.ref.alive) { bot.target = null; return; }

  const dx = tx - bot.x, dy = ty - bot.y;
  const d = Math.hypot(dx,dy) || 0.001;
  const desiredSpeed = Math.max(0.5, 1.8 - Math.sqrt(bot.mass)/20); // larger bots slower
  bot.vx += (dx/d)*desiredSpeed*dt*30;
  bot.vy += (dy/d)*desiredSpeed*dt*30;

  // friction
  bot.vx *= 0.96;
  bot.vy *= 0.96;

  // clamp
  if(Math.hypot(bot.vx, bot.vy) > 14) {
    const s = 14 / Math.hypot(bot.vx, bot.vy);
    bot.vx *= s; bot.vy *= s;
  }
}

// ----- Game loop -----
let last = performance.now();
function step(){
  const now = performance.now();
  const dt = Math.min(0.05, (now - last)/1000);
  last = now;

  // update player input -> velocity
  // direction from pointer (desktop) or joystick (mobile) or keys
  let inputX = 0, inputY = 0;
  // keyboard WASD
  if(keys['w']||keys['arrowup']) inputY -= 1;
  if(keys['s']||keys['arrowdown']) inputY += 1;
  if(keys['a']||keys['arrowleft']) inputX -= 1;
  if(keys['d']||keys['arrowright']) inputX += 1;

  // mouse direction: move towards mouse location on screen
  if(!('ontouchstart' in window) && !(Math.abs(inputX)+Math.abs(inputY) > 0)){
    // map mouse to world direction
    const cx = canvas.width/2, cy = canvas.height/2;
    const screenDX = mouse.x - cx, screenDY = mouse.y - cy;
    inputX = Math.sign(screenDX) * Math.min(1, Math.abs(screenDX)/(canvas.width*0.25));
    inputY = Math.sign(screenDY) * Math.min(1, Math.abs(screenDY)/(canvas.height*0.25));
  }

  // mobile joystick override
  if(Math.abs(joyVec.x) > 0.01 || Math.abs(joyVec.y) > 0.01){
    inputX = joyVec.x; inputY = -joyVec.y; // thumb y is inverted
  }

  // compute desired speed based on mass
  const speed = Math.max(70 / Math.sqrt(player.mass), 1.2);
  // apply acceleration
  player.vx += inputX * speed * dt * 6;
  player.vy += inputY * speed * dt * 6;
  // friction
  player.vx *= 0.92;
  player.vy *= 0.92;

  // update bots
  for(const b of bots) updateBot(b, dt);

  // update positions
  for(const entity of blobs){
    if(!entity.alive) continue;
    entity.x += (entity.vx || 0) * dt * 60;
    entity.y += (entity.vy || 0) * dt * 60;
    // clamp to arena
    entity.x = Math.max(0, Math.min(ARENA.w, entity.x));
    entity.y = Math.max(0, Math.min(ARENA.h, entity.y));
  }
  // pellets with velocity (ejected)
  for(let i = pellets.length-1;i>=0;i--){
    const pe = pellets[i];
    if(pe.vx || pe.vy){
      pe.x += (pe.vx||0) * dt * 60;
      pe.y += (pe.vy||0) * dt * 60;
      pe.life = (pe.life || 3000) - (dt*1000);
      if(pe.life <= 0){ pellets.splice(i,1); continue; }
    }
  }

  // update camera to follow player smoothly
  camera.x += (player.x - camera.x) * 0.12;
  camera.y += (player.y - camera.y) * 0.12;

  // collisions: player & blobs eat pellets
  // combine list of all eaters (blobs) including splits in blobs array
  const eaters = blobs.filter(b=>b.alive);

  // eat pellets
  for(const e of eaters){
    for(let i = pellets.length-1;i>=0;i--){
      const pe = pellets[i];
      const d = Math.hypot(pe.x - e.x, pe.y - e.y);
      const r = massToRadius(e.mass || 8) + (pe.r||4);
      if(d < r){
        // eat
        e.mass = (e.mass || START_MASS) + 1;
        pellets.splice(i,1);
        // spawn replacement pellet to keep density
        pellets.push(spawnPellet(Date.now()));
      }
    }
  }

  // eat blobs (bigger eats smaller)
  for(let i = 0; i < eaters.length; i++){
    for(let j = 0; j < eaters.length; j++){
      if(i===j) continue;
      const A = eaters[i], B = eaters[j];
      if(!A.alive || !B.alive) continue;
      const ra = massToRadius(A.mass||8), rb = massToRadius(B.mass||8);
      const d = Math.hypot(A.x - B.x, A.y - B.y);
      if(d < (ra - rb*0.6) && A.mass > B.mass * 1.18){
        // A can consume B
        A.mass += B.mass * 0.9;
        B.alive = false;
        // if B was player split-piece, remove from blobs
      }
    }
  }

  // remove dead bots from active list
  for(const b of bots){ if(!b.alive){ /* leave for spectator */ } }

  // tidy: rebuild blobs (keep split pieces too)
  rebuildBlobList();

  // update HUD
  scoreEl.textContent = 'Mass: ' + Math.floor(player.mass || 0);
  playersEl.textContent = 'Bots: ' + bots.filter(b=>b.alive).length;

  // handle merging behavior: any small split pieces close to parent will be absorbed over time (simplified)
  // (Not implemented fully to keep code simple)

  // render
  render();

  // schedule next step
  requestAnimationFrame(step);
}

// ----- helpers/spawn pellet -----
function spawnPellet(seed){
  return {
    id: 'p' + seed + '_' + Math.floor(Math.random()*10000),
    x: Math.floor(rand(0, ARENA.w)),
    y: Math.floor(rand(0, ARENA.h)),
    r: 4 + Math.random()*2,
    color: '#ffd37a'
  };
}

// ----- rebuild blob list (player + live bots + any split pieces in blobs) -----
function rebuildBlobList(){
  // blobs contains player, bots + split pieces; ensure it contains current live bots and player
  const splitPieces = blobs.filter(b=>b.id && b.id.includes('_split_') && b.alive);
  blobs = [player].concat(bots.filter(b=>b.alive)).concat(splitPieces);
}

// ----- initial build
rebuildBlobList();

// ----- Render -----
function worldToScreen(wx, wy){
  // camera centered on screen
  const sx = (wx - camera.x) + canvas.width/2;
  const sy = (wy - camera.y) + canvas.height/2;
  return { x: sx, y: sy };
}

function render(){
  // clear
  ctx.fillStyle = '#071428';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // draw background grid subtly
  ctx.save();
  ctx.translate(canvas.width/2 - camera.x, canvas.height/2 - camera.y);
  const gridSize = 100;
  ctx.strokeStyle = 'rgba(255,255,255,0.02)';
  ctx.lineWidth = 1;
  for(let gx = 0; gx <= ARENA.w; gx += gridSize){
    ctx.beginPath(); ctx.moveTo(gx,0); ctx.lineTo(gx, ARENA.h); ctx.stroke();
  }
  for(let gy = 0; gy <= ARENA.h; gy += gridSize){
    ctx.beginPath(); ctx.moveTo(0,gy); ctx.lineTo(ARENA.w, gy); ctx.stroke();
  }
  ctx.restore();

  // draw pellets
  for(const p of pellets){
    const s = worldToScreen(p.x, p.y);
    ctx.beginPath();
    ctx.fillStyle = p.color;
    ctx.arc(s.x, s.y, p.r, 0, Math.PI*2);
    ctx.fill();
  }

  // draw blobs sorted by size (small first)
  const drawList = blobs.filter(b=>b.alive).slice().sort((a,b)=> (a.mass || 0) - (b.mass || 0));
  for(const b of drawList){
    const r = massToRadius(b.mass || START_MASS);
    const s = worldToScreen(b.x, b.y);
    // body
    ctx.beginPath();
    ctx.fillStyle = b.color || '#86C232';
    ctx.arc(s.x, s.y, r, 0, Math.PI*2);
    ctx.fill();
    // outline
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.lineWidth = 3;
    ctx.arc(s.x, s.y, r, 0, Math.PI*2);
    ctx.stroke();
    // label
    ctx.fillStyle = '#021020';
    ctx.font = `${Math.max(10, Math.min(18, r/2))}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const label = (b.isBot ? 'Bot' : 'You');
    ctx.fillText(label, s.x, s.y);
  }

  // draw crosshair / center indicator
  ctx.beginPath();
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.moveTo(canvas.width/2-8, canvas.height/2);
  ctx.lineTo(canvas.width/2+8, canvas.height/2);
  ctx.moveTo(canvas.width/2, canvas.height/2-8);
  ctx.lineTo(canvas.width/2, canvas.height/2+8);
  ctx.stroke();
}

// ----- helper: consume pellet by blob entity (used above) already done in collision check -----
// ----- start game -----
requestAnimationFrame(step);

// ----- initial UI hint -----
setTimeout(()=> alert('Welcome to Blob Arena!\nGrow by eating pellets and bots smaller than you.\nControls:\n- PC: WASD or arrows to move, SPACE to split, E to eject\n- Mobile: use joystick and Split/Eject buttons'), 300);

// Export for debugging if needed
window.BlobArena = { player, bots, pellets, blobs, camera };
