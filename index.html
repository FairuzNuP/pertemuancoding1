<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>TETRIS 3D ‚Äî Sunset Cyberpunk</title>

<!-- Three.js (stable CDN) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r146/three.min.js"></script>

<style>
  :root{
    --bg:#07020a;
    --panel:rgba(255,255,255,0.03);
    --accent1:#ff7a2d; /* orange */
    --accent2:#ff4fb8; /* pink */
    --muted:#9fb0c7;
    --glass: rgba(255,255,255,0.04);
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#0b0410,#06020a);font-family:Inter,Arial,sans-serif;color:#eaf6ff;overflow:hidden}
  .app{display:flex;flex-direction:column;height:100vh;box-sizing:border-box;padding:18px;gap:12px}
  header{display:flex;align-items:center;gap:12px}
  h1{margin:0;font-family:Orbitron,Inter,Arial;font-weight:700;letter-spacing:1px;color:var(--accent1)}
  .top-right{margin-left:auto;display:flex;gap:8px}
  .btn{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);padding:8px 12px;border-radius:10px;color:#eaf6ff;cursor:pointer}
  .main{display:flex;gap:18px;flex:1;align-items:stretch}
  /* left: 3D canvas */
  #viewport{flex:1;background:linear-gradient(180deg,#05030a,#04030a);border-radius:12px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 30px 100px rgba(0,0,0,0.8);position:relative;overflow:hidden}
  #hud-overlay{position:absolute;right:14px;top:14px;display:flex;flex-direction:column;gap:8px;z-index:10}
  .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);backdrop-filter:blur(6px);border-radius:10px;padding:10px;border:1px solid rgba(255,255,255,0.03);min-width:160px}
  .small{font-size:12px;color:var(--muted)}
  .stats{display:flex;gap:8px}
  .stat{display:flex;flex-direction:column;align-items:center;padding:6px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);min-width:64px}
  .stat .num{font-weight:700;color:var(--accent2)}
  /* right: controls & panels */
  aside{width:360px;display:flex;flex-direction:column;gap:12px}
  .panel{padding:12px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border:1px solid rgba(255,255,255,0.03)}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  input[type="range"]{width:100%}
  .mini-canvas{width:120px;height:120px;border-radius:8px;background:linear-gradient(180deg,#02060a,#041018);border:1px solid rgba(255,255,255,0.03)}
  .leaderboard-list{max-height:200px;overflow:auto;margin-top:8px}
  .lb-item{display:flex;justify-content:space-between;padding:8px;border-radius:8px;margin-bottom:6px;background:linear-gradient(90deg, rgba(255,255,255,0.01), transparent)}
  footer{font-size:12px;color:var(--muted);text-align:center;margin-top:6px}
  /* modal */
  .modal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:linear-gradient(180deg,#061022,#021018);padding:16px;border-radius:12px;border:1px solid rgba(255,255,255,0.04);z-index:999;display:none;min-width:320px}
  .row{display:flex;gap:8px;align-items:center}
  .theme-btn{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);cursor:pointer;background:transparent}
  .shop-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .power-btn{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);cursor:pointer}
  a.small-link{color:var(--accent1);text-decoration:none;font-size:12px}
</style>
</head>
<body>
<div class="app">
  <header>
    <h1>TETRIS 3D ‚Äî Sunset Cyberpunk</h1>
    <div class="top-right">
      <button class="btn" id="btn-shop">üè¨ Shop</button>
      <button class="btn" id="btn-ai">ü§ñ AI: Off</button>
      <button class="btn" id="btn-reset">üîÅ Restart</button>
    </div>
  </header>

  <div class="main">
    <div id="viewport">
      <!-- Three.js will render here -->
      <div id="hud-overlay">
        <div class="card">
          <div class="small">Player</div>
          <div style="font-weight:700">Guest</div>
        </div>

        <div class="card stats">
          <div class="stat">
            <div class="small">Skor</div>
            <div class="num" id="score">0</div>
          </div>
          <div class="stat">
            <div class="small">Level</div>
            <div class="num" id="level">1</div>
          </div>
          <div class="stat">
            <div class="small">Baris</div>
            <div class="num" id="lines">0</div>
          </div>
        </div>

        <div class="card">
          <div class="small">Coins</div>
          <div style="font-weight:700;color:var(--accent1)" id="coins">0</div>
        </div>
      </div>
      <!-- help overlay -->
      <div id="overlay-text" style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);pointer-events:none;color:#fff;display:none;text-align:center"></div>
    </div>

    <aside>
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div><div class="small">Next</div><canvas id="next" class="mini-canvas"></canvas></div>
          <div><div class="small">Hold</div><canvas id="hold" class="mini-canvas"></canvas></div>
        </div>
        <div style="margin-top:8px" class="small">Controls: ‚Üê ‚Üí (move), ‚Üë (rotate), ‚Üì (soft), Space (hard), Shift (turbo), C (hold), P (pause)</div>
      </div>

      <div class="panel">
        <div class="row" style="justify-content:space-between;align-items:center">
          <div class="small">Volume</div>
          <div style="width:40%"><input id="vol" type="range" min="0" max="1" step="0.01" value="0.45"></div>
        </div>
        <div style="margin-top:8px" class="row">
          <button class="btn" id="btn-music">üéµ Music</button>
          <button class="btn" id="btn-sfx">üîä SFX</button>
        </div>

        <div style="margin-top:10px">
          <div class="small">Power-ups</div>
          <div style="display:flex;gap:8px;margin-top:6px">
            <button class="power-btn" id="power-freeze">Freeze (5s)</button>
            <button class="power-btn" id="power-bomb">Bomb (area)</button>
            <button class="power-btn" id="power-clear">Clear Random</button>
          </div>
        </div>
      </div>

      <div class="panel">
        <h3 style="margin:0 0 8px 0">Leaderboard Lokal</h3>
        <div style="display:flex;gap:8px;margin-bottom:8px">
          <input id="playerName" maxlength="12" placeholder="Nama (max 12)" style="flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:#eaf6ff">
          <button class="btn" id="btn-save">üíæ Save</button>
        </div>
        <div class="leaderboard-list" id="leaderboard"></div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button class="btn" id="btn-clear-lb">Clear LB</button>
          <button class="btn" id="btn-export">Export</button>
        </div>
      </div>

      <div class="panel">
        <h3 style="margin:0 0 8px 0">Shop</h3>
        <div class="small">Beli tema visual & power-up permanen</div>
        <div style="margin-top:8px" class="shop-grid">
          <!-- dynamic shop items -->
        </div>
      </div>
    </aside>
  </div>

  <footer>Made 2025 ‚Äî Tetris 3D ‚Ä¢ Sunset Cyberpunk ‚Äî Ekskul Coding</footer>
</div>

<!-- Shop modal -->
<div class="modal" id="modal-shop">
  <h3>Shop</h3>
  <div style="margin-top:8px" class="shop-grid" id="shop-items-modal"></div>
  <div style="text-align:right;margin-top:12px">
    <button class="btn" id="close-shop">Tutup</button>
  </div>
</div>

<!-- Pause / help modal -->
<div class="modal" id="modal-help" style="min-width:420px">
  <h3 id="modal-title">Paused</h3>
  <div id="modal-body" style="margin-top:8px;color:var(--muted);font-size:13px"></div>
  <div style="text-align:right;margin-top:12px">
    <button class="btn" id="modal-close">Close</button>
  </div>
</div>

<script>
/* ---------------------------------------
   Tetris 3D ‚Äî Full implementation
   - Three.js scene for blocks (cubes)
   - Game logic adapted to 3D (grid remains 2D but cubes are 3D)
   - AI mode, power-ups, coins & shop
   - Leaderboard localStorage, music & SFX
   --------------------------------------- */

/* ---------- Config ---------- */
const COLS = 10, ROWS = 20;
const CELL = 1; // unit size in Three.js space
const DROP_BASE = 1000; // ms

/* ---------- State ---------- */
let scene, camera, renderer, light;
let gridHelperMesh; // optional visual
let boardGroup; // group that contains stacked cubes
let activeGroup; // current falling piece group
let nextPieceCanvas = document.getElementById('next');
let holdCanvas = document.getElementById('hold');
let nextCtx = nextPieceCanvas.getContext('2d');
let holdCtx = holdCanvas.getContext('2d');

let arena = createMatrix(COLS, ROWS); // 0 = empty, >0 = piece id
let pieceIndex = 1; // numeric value for color mapping
let piecesQueue = [];
let currentPiece = null; // {matrix, x, y, id, rotationsUsed}
let holdPiece = null;
let canHold = true;
let dropCounter = 0;
let dropInterval = DROP_BASE;
let lastTime = performance.now();
let running = true;
let paused = false;
let score = 0, lines = 0, level = 1;
let coins = parseInt(localStorage.getItem('t3_coins')||'0',10) || 0;
let highscore = parseInt(localStorage.getItem('t3_high')||'0',10) || 0;
let aiMode = false;
let musicOn = false, sfxOn = true;
let music, sfxLock, sfxClear, sfxDrop, sfxPower;
let particles = [];
let challengeEnabled = true;
let challengeTimer = 0;

/* themes for shop */
const THEMES = {
  'sunset-cyberpunk': { name:'Sunset Cyberpunk', bgColor:'#0b0410', accent1:'#ff7a2d', accent2:'#ff4fb8' },
  'nebula': { name:'Nebula Purple', bgColor:'#050018', accent1:'#7a4bff', accent2:'#ff6bd6' },
  'aurora': { name:'Aurora Teal', bgColor:'#00121a', accent1:'#00f2c3', accent2:'#60ffb0' }
};
let currentTheme = localStorage.getItem('t3_theme') || 'sunset-cyberpunk';
applyTheme(currentTheme);

/* color palette for pieces (numeric index -> color) */
const COLORS = [null, '#ff7a2d', '#ff4fb8', '#ffd166', '#7cffb2', '#ff6b6b', '#ff8fb1', '#ffffff'];

/* Tetromino shapes (same as 2D classic) */
const SHAPES = {
  I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
  O: [[2,2],[2,2]],
  T: [[0,3,0],[3,3,3],[0,0,0]],
  S: [[0,4,4],[4,4,0],[0,0,0]],
  Z: [[5,5,0],[0,5,5],[0,0,0]],
  J: [[6,0,0],[6,6,6],[0,0,0]],
  L: [[0,0,7],[7,7,7],[0,0,0]]
};
const PIECE_KEYS = Object.keys(SHAPES);

/* ---------- Three.js init ---------- */
function initThree(){
  const container = document.getElementById('viewport');
  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  container.appendChild(renderer.domElement);

  scene = new THREE.Scene();

  // camera
  camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
  camera.position.set(0, 10, 20);
  camera.lookAt(0, 6, 0);

  // lights
  light = new THREE.DirectionalLight(0xffffff, 0.9);
  light.position.set(10, 20, 10);
  scene.add(light);
  scene.add(new THREE.AmbientLight(0xffffff, 0.25));

  // boardGroup at center
  boardGroup = new THREE.Group();
  boardGroup.position.set(-COLS/2 + 0.5, 0, 0); // center horizontally
  scene.add(boardGroup);

  // subtle floor / fog
  renderer.setClearColor( THEMES[currentTheme].bgColor || '#050018' );
  scene.fog = new THREE.FogExp2('#000000', 0.02);

  // starfield background plane (simple)
  const bgGeo = new THREE.PlaneGeometry(100, 60);
  const bgMat = new THREE.MeshBasicMaterial({ color: THEMES[currentTheme].bgColor || '#050018', side: THREE.DoubleSide });
  const bgMesh = new THREE.Mesh(bgGeo, bgMat);
  bgMesh.position.set(0, 10, -40);
  scene.add(bgMesh);

  // optional grid helper - commented to reduce clutter
  // const grid = new THREE.GridHelper(20, 20, 0x444444, 0x111111);
  // scene.add(grid);

  // responsive
  window.addEventListener('resize', ()=> {
    const w = container.clientWidth, h = container.clientHeight;
    camera.aspect = w/h;
    camera.updateProjectionMatrix();
    renderer.setSize(w,h);
  });
}
initThree();

/* ---------- Utility ---------- */
function createMatrix(w,h){ const m=[]; for(let y=0;y<h;y++){ m.push(new Array(w).fill(0)); } return m; }
function clone(m){ return m.map(r=>r.slice()); }
function randPiece(){ const k = PIECE_KEYS[Math.floor(Math.random()*PIECE_KEYS.length)]; return SHAPES[k].map(r=>r.slice()); }

/* ---------- Visual helpers: create cube (voxel) ---------- */
function createCubeMesh(color){
  const geo = new THREE.BoxGeometry(CELL, CELL, CELL);
  const mat = new THREE.MeshStandardMaterial({ color, roughness:0.4, metalness:0.2, emissive: color, emissiveIntensity: 0.02 });
  const mesh = new THREE.Mesh(geo, mat);
  return mesh;
}

/* map arena to Three.js meshes. We'll keep a 2D array of meshes for stacked blocks */
let meshGrid = createMatrix(COLS, ROWS);
function rebuildMeshGrid(){
  // remove existing group children
  for(let y=0;y<meshGrid.length;y++){
    for(let x=0;x<meshGrid[y].length;x++){
      if(meshGrid[y][x]){ boardGroup.remove(meshGrid[y][x]); meshGrid[y][x].geometry.dispose && meshGrid[y][x].material.dispose && meshGrid[y][x].material.dispose(); meshGrid[y][x] = null; }
    }
  }
  // recreate from arena
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const val = arena[y][x];
      if(val){
        const mesh = createCubeMesh(COLORS[val] || '#fff');
        mesh.position.set(x + 0.0, (ROWS - 1 - y) * 1 + 0.5, 0); // y inverted so row 0 at top
        boardGroup.add(mesh);
        meshGrid[y][x] = mesh;
      }
    }
  }
}

/* ---------- Piece visuals ---------- */
function createPieceGroup(matrix, id){
  const group = new THREE.Group();
  for(let y=0;y<matrix.length;y++){
    for(let x=0;x<matrix[y].length;x++){
      const v = matrix[y][x];
      if(v){
        const mesh = createCubeMesh(COLORS[v] || '#fff');
        mesh.position.set(x + 0.5, -y + 0.5, 0);
        group.add(mesh);
      }
    }
  }
  group.userData = { id };
  return group;
}
function placeActiveGroupAt(group, px, py){
  // group local origin is at top-left of its bounding matrix; we need to position to board coords
  group.position.set(px, (ROWS - 1 - py) , 0); // vertical invert
}

/* ---------- Game logic ---------- */
function refillQueue(){
  while(piecesQueue.length < 6) piecesQueue.push(randPiece());
}
function spawnPiece(){
  refillQueue();
  const mat = piecesQueue.shift();
  const id = (pieceIndex % 7) + 1;
  pieceIndex++;
  currentPiece = { matrix: mat, x: Math.floor((COLS - mat[0].length)/2), y: 0, id };
  canHold = true;
  // create active group for visuals
  if(activeGroup){ scene.remove(activeGroup); activeGroup = null; }
  activeGroup = createPieceGroup(mat, id);
  placeActiveGroupAt(activeGroup, currentPiece.x, currentPiece.y);
  scene.add(activeGroup);
  drawMini(nextCtx, piecesQueue[0]);
  drawHold();
  // collision on spawn -> game over
  if(collide(arena, currentPiece)){ running = false; showModal('Game Over', `Skor ${score}. Simpan ke leaderboard jika mau.`); }
}
function collide(board, piece){
  const m = piece.matrix;
  for(let y=0;y<m.length;y++){
    for(let x=0;x<m[y].length;x++){
      if(m[y][x]){
        const ay = board[piece.y + y];
        if(!ay || ay[piece.x + x] !== 0) return true;
      }
    }
  }
  return false;
}
function mergePiece(){
  const m = currentPiece.matrix;
  for(let y=0;y<m.length;y++){
    for(let x=0;x<m[y].length;x++){
      if(m[y][x]) arena[currentPiece.y + y][currentPiece.x + x] = currentPiece.id;
    }
  }
  try{ if(sfxLock && sfxOn){ sfxLock.currentTime = 0; sfxLock.play(); } }catch(e){}
  rebuildMeshGrid();
}
function rotateMatrix(matrix, dir){
  for(let y=0;y<matrix.length;y++) for(let x=0;x<y;x++) [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
  if(dir > 0) matrix.forEach(row => row.reverse()); else matrix.reverse();
}
function tryRotate(dir){
  rotateMatrix(currentPiece.matrix, dir);
  // simple kick tests: try left/right
  if(collide(arena, currentPiece)){
    currentPiece.x += 1;
    if(collide(arena, currentPiece)) { currentPiece.x -= 2; if(collide(arena, currentPiece)) { currentPiece.x += 1; rotateMatrix(currentPiece.matrix, -dir); } }
  }
  updateActiveGroup();
}
function updateActiveGroup(){
  // remove old visuals and create new group representing currentPiece.matrix
  if(activeGroup){ scene.remove(activeGroup); activeGroup = null; }
  activeGroup = createPieceGroup(currentPiece.matrix, currentPiece.id);
  placeActiveGroupAt(activeGroup, currentPiece.x, currentPiece.y);
  scene.add(activeGroup);
}

/* sweep lines */
function sweep(){
  let rowCount = 0;
  outer: for(let y = ROWS - 1; y >= 0; y--){
    for(let x=0;x<COLS;x++){
      if(arena[y][x] === 0) continue outer;
    }
    // remove row
    arena.splice(y,1);
    arena.unshift(new Array(COLS).fill(0));
    rowCount++;
    // explosion particles around row
    spawnExplosion(y);
    y++; // stay at same index after unshift
  }
  if(rowCount > 0){
    const points = [0, 40, 100, 300, 1200];
    score += (points[rowCount] || rowCount * 100) * level;
    lines += rowCount;
    level = Math.floor(lines / 10) + 1;
    dropInterval = Math.max(80, DROP_BASE - (level - 1) * 70);
    coins += rowCount * 5; // reward coins
    saveCoins();
    try{ if(sfxClear && sfxOn){ sfxClear.currentTime = 0; sfxClear.play(); } }catch(e){}
    rebuildMeshGrid();
    updateHUD();
  }
  return rowCount;
}

/* ---------- Particles for effects ---------- */
function spawnExplosion(rowY){
  for(let i=0;i<40;i++){
    particles.push({
      x: (Math.random()*COLS), y: ROWS - 1 - rowY + (Math.random()*0.8), vx: (Math.random()-0.5)*2.5, vy: (Math.random()-1.5)*2.5,
      life: Math.random()*60 + 40, color: COLORS[Math.ceil(Math.random()*7)]
    });
  }
}

/* ---------- Power-ups ---------- */
function powerFreeze(){
  // pause drop for 5 seconds but keep controls
  paused = true;
  showOverlay('Freeze', 'Waktu dibekukan 5 detik');
  setTimeout(()=>{ paused = false; hideOverlay(); }, 5000);
  // cost or consume: optional
  coins = Math.max(0, coins - 10); saveCoins(); updateHUD();
}
function powerBomb(){
  // bomb: clear 2 rows around current piece y
  const center = Math.min(ROWS - 2, currentPiece.y + 1);
  for(let r = center - 1; r <= center + 1; r++){
    if(r >= 0 && r < ROWS){
      arena.splice(r,1);
      arena.unshift(new Array(COLS).fill(0));
    }
  }
  spawnExplosion(center);
  coins = Math.max(0, coins - 15); saveCoins(); updateHUD();
  rebuildMeshGrid();
}
function powerClearRandom(){
  // remove some random filled cells
  let removed = 0;
  for(let i=0;i<3;i++){
    const row = Math.floor(Math.random()*ROWS);
    arena.splice(row,1);
    arena.unshift(new Array(COLS).fill(0));
    removed++;
  }
  spawnExplosion(ROWS - 4);
  coins = Math.max(0, coins - 12); saveCoins(); updateHUD();
  rebuildMeshGrid();
}

/* ---------- AI: very simple greedy agent ---------- */
function aiStep(){
  if(!aiMode || !currentPiece) return;
  // trivial AI: try positions x from 0..COLS-1 and rotations 0..3, pick lowest resulting height
  let best = null;
  const original = { matrix: clone(currentPiece.matrix), x: currentPiece.x, y: currentPiece.y };
  for(let rot=0; rot<4; rot++){
    // rotate copy
    const tempMat = clone(original.matrix);
    for(let r=0;r<rot;r++) rotateMatrix(tempMat, 1);
    const w = tempMat[0].length;
    for(let xPos= -1; xPos <= COLS - w + 1; xPos++){
      const testPiece = { matrix: tempMat.map(r=>r.slice()), x: xPos, y: 0, id: original.matrix[1] };
      // simulate drop
      while(!collide(arena, testPiece)) testPiece.y++;
      testPiece.y--;
      if(testPiece.y < 0) continue;
      // score by lowest stack height after merge
      const copyArena = clone(arena);
      for(let y=0;y<testPiece.matrix.length;y++){
        for(let x=0;x<testPiece.matrix[y].length;x++){
          if(testPiece.matrix[y][x]) copyArena[testPiece.y + y][testPiece.x + x] = 1;
        }
      }
      // compute aggregate height
      let agg = 0;
      for(let c=0;c<COLS;c++){
        let colH = 0;
        for(let r=0;r<ROWS;r++){ if(copyArena[r][c]){ colH = ROWS - r; break; } }
        agg += colH;
      }
      if(!best || agg < best.score){ best = {score:agg, rot, xPos}; }
    }
  }
  if(best){
    // apply rotations
    for(let r=0;r<best.rot;r++) tryRotate(1);
    // move horizontally towards xPos
    if(best.xPos > currentPiece.x) playerMove(1);
    else if(best.xPos < currentPiece.x) playerMove(-1);
    else {
      // drop
      playerDropHard();
    }
  }
}

/* ---------- Input handlers ---------- */
function playerMove(dir){
  currentPiece.x += dir;
  if(collide(arena, currentPiece)) currentPiece.x -= dir;
  updateActiveGroup();
}
function playerRotate(dir){
  tryRotate(dir);
}
function playerDropHard(){
  try{ if(sfxDrop && sfxOn){ sfxDrop.currentTime = 0; sfxDrop.play(); } }catch(e){}
  while(!collide(arena, currentPiece)) currentPiece.y++;
  currentPiece.y--;
  updateActiveGroup();
  mergePiece();
  sweep();
  spawnPiece();
}
function playerSoftDrop(){
  currentPiece.y++;
  if(collide(arena, currentPiece)){
    currentPiece.y--;
    mergePiece();
    sweep();
    spawnPiece();
  }
  updateActiveGroup();
  dropCounter = 0;
}
function doHold(){
  if(!canHold) return;
  if(!holdPiece){
    holdPiece = clone(currentPiece.matrix);
    scene.remove(activeGroup);
    spawnPiece();
  } else {
    const temp = clone(currentPiece.matrix);
    currentPiece.matrix = clone(holdPiece);
    holdPiece = temp;
    currentPiece.x = Math.floor((COLS - currentPiece.matrix[0].length)/2);
    currentPiece.y = 0;
    updateActiveGroup();
  }
  canHold = false;
  try{ if(sfxPower && sfxOn){ sfxPower.currentTime = 0; sfxPower.play(); } }catch(e){}
  drawHold();
}

/* ---------- HUD & canvas mini draws ---------- */
function drawMini(ctx2d, matrix){
  const W = ctx2d.canvas.width, H = ctx2d.canvas.height;
  ctx2d.clearRect(0,0,W,H);
  ctx2d.fillStyle = '#020610';
  ctx2d.fillRect(0,0,W,H);
  if(!matrix) return;
  const cell = Math.floor(Math.min(W/4, H/4) - 4);
  const w = matrix[0].length, h = matrix.length;
  const offsetX = Math.floor((4 - w)/2);
  const offsetY = Math.floor((4 - h)/2);
  for(let y=0;y<4;y++){
    for(let x=0;x<4;x++){
      const mx = x - offsetX, my = y - offsetY;
      let val = 0;
      if(my >=0 && my < h && mx >=0 && mx < w) val = matrix[my][mx];
      if(val){
        ctx2d.fillStyle = COLORS[val];
        ctx2d.fillRect(x*cell + 8, y*cell + 8, cell-6, cell-6);
        ctx2d.strokeStyle = 'rgba(0,0,0,0.2)';
        ctx2d.strokeRect(x*cell + 8, y*cell + 8, cell-6, cell-6);
      }
    }
  }
}
function drawHold(){
  drawMini(holdCtx, holdPiece);
}

/* ---------- HUD updates & storage ---------- */
function updateHUD(){
  document.getElementById('score').innerText = score;
  document.getElementById('level').innerText = level;
  document.getElementById('lines').innerText = lines;
  document.getElementById('coins').innerText = coins;
}
function saveCoins(){ localStorage.setItem('t3_coins', String(coins)); }
function saveHighscore(){ localStorage.setItem('t3_high', String(Math.max(highscore, score))); }

/* ---------- Leaderboard ---------- */
function getLB(){ try{ return JSON.parse(localStorage.getItem('tetris3d_lb')||'[]'); } catch(e){ return []; } }
function renderLeaderboard(){
  const container = document.getElementById('leaderboard');
  container.innerHTML = '';
  const lb = getLB();
  if(lb.length === 0){ container.innerHTML = '<div class="small">Belum ada skor.</div>'; return; }
  lb.forEach((it, idx) => {
    const el = document.createElement('div');
    el.className = 'lb-item';
    el.innerHTML = `<div><strong>${idx+1}. ${it.name}</strong><div class="small">${new Date(it.ts).toLocaleString()}</div></div><div style="font-weight:700">${it.score}</div>`;
    container.appendChild(el);
  });
}
function saveToLB(){
  const name = (document.getElementById('playerName').value || 'Guest').slice(0,12);
  const lb = getLB();
  lb.push({ name, score, ts: Date.now() });
  lb.sort((a,b)=>b.score - a.score);
  localStorage.setItem('tetris3d_lb', JSON.stringify(lb.slice(0,10)));
  renderLeaderboard();
}

/* ---------- Shop ---------- */
const SHOP_ITEMS = [
  { id:'nebula', label:'Nebula Theme', price: 80, type:'theme' },
  { id:'aurora', label: 'Aurora Theme', price: 120, type:'theme' },
  { id:'perm-freeze', label:'Permanent Freeze Power', price: 150, type:'power' }
];
function renderShop(){
  const grid = document.querySelector('.panel .shop-grid') || document.querySelector('#shop-items-modal');
  const rightPanelGrid = document.querySelector('.panel .shop-grid');
  // render small initial in right panel
  const rp = document.querySelector('.panel .shop-grid');
  rp.innerHTML = '';
  SHOP_ITEMS.forEach(it=>{
    const div = document.createElement('div');
    div.style.padding = '8px';
    div.style.borderRadius = '8px';
    div.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.01), transparent)';
    div.innerHTML = `<div style="font-weight:600">${it.label}</div><div class="small">Price: ${it.price} coins</div><div style="margin-top:6px"><button class="btn" data-id="${it.id}">Buy</button></div>`;
    rp.appendChild(div);
  });
  // modal listing
  const modalGrid = document.getElementById('shop-items-modal');
  modalGrid.innerHTML = '';
  SHOP_ITEMS.forEach(it=>{
    const div = document.createElement('div');
    div.style.padding='8px';
    div.style.borderRadius='8px';
    div.style.background='linear-gradient(180deg, rgba(255,255,255,0.01), transparent)';
    div.innerHTML = `<div style="font-weight:600">${it.label}</div><div class="small">Price: ${it.price} coins</div><div style="margin-top:6px"><button class="btn" data-id="${it.id}">Buy</button></div>`;
    modalGrid.appendChild(div);
  });
  // buy handlers
  document.querySelectorAll('#shop-items-modal .btn, .panel .btn[data-id]').forEach(b => {
    b.addEventListener('click', (e) => {
      const id = e.currentTarget.getAttribute('data-id');
      buyItem(id);
    });
  });
}
function buyItem(id){
  const item = SHOP_ITEMS.find(s=>s.id===id);
  if(!item) return alert('Item not found');
  if(coins < item.price) return alert('Koin tidak cukup');
  coins -= item.price; saveCoins(); updateHUD();
  if(item.type === 'theme'){
    // unlock and auto-apply
    localStorage.setItem('t3_theme_' + id, '1');
    applyTheme(id);
    alert('Tema dibeli dan diterapkan!');
  } else if(item.id === 'perm-freeze'){
    localStorage.setItem('t3_perm_freeze', '1');
    alert('Permanent Freeze dibeli! (Gunakan tombol Freeze di Power-ups)');
  }
}

/* ---------- Game loop ---------- */
function update(time=performance.now()){
  if(!running) return;
  const delta = time - lastTime;
  lastTime = time;
  if(paused){ requestAnimationFrame(update); return; }
  // AI step small interval
  if(aiMode) aiStep();
  // drop counter
  dropCounter += delta;
  challengeTimer += delta;
  if(challengeEnabled && challengeTimer > 15000 && level >= 3){
    challengeTimer = 0;
    // push a noisy row
    const newRow = new Array(COLS).fill(0).map(()=> Math.random() < 0.2 ? 0 : Math.ceil(Math.random()*7) );
    arena.push(newRow);
    arena.shift();
    rebuildMeshGrid();
    spawnExplosion(ROWS - 2);
  }
  if(dropCounter > dropInterval){
    currentPiece.y++;
    if(collide(arena, currentPiece)){
      currentPiece.y--;
      mergePiece();
      sweep();
      spawnPiece();
    }
    updateActiveGroup();
    dropCounter = 0;
  }
  renderFrame();
  requestAnimationFrame(update);
}

/* rendering: Three.js + particles + HUD mini canvases */
function renderFrame(){
  // animate some slight rotation to boardGroup for 3D feel
  boardGroup.rotation.y = Math.sin(performance.now()/3000) * 0.03;
  // render particles as sprites using simple 2D overlay on renderer
  // We will draw particles as small colored squares by creating a 2D canvas overlay
  // Instead, for simplicity here, spawn small Cube sprites and animate them (cheap)
  // but to keep performance OK, we will animate existing particle array and remove expired
  particles.forEach((p, idx) => {
    // small temporary sprites: emulate by adding to scene only first time
    if(!p.mesh){
      const g = new THREE.BoxGeometry(0.12,0.12,0.12);
      const m = new THREE.MeshBasicMaterial({ color: p.color });
      p.mesh = new THREE.Mesh(g,m);
      scene.add(p.mesh);
    }
    p.x += p.vx * 0.03;
    p.y += p.vy * 0.03;
    p.vy += 0.01;
    p.life -= 1;
    p.mesh.position.set(p.x - COLS/2, p.y, 0.5);
    if(p.life <= 0){
      scene.remove(p.mesh);
      if(p.mesh.geometry) p.mesh.geometry.dispose();
      if(p.mesh.material) p.mesh.material.dispose();
      particles.splice(idx,1);
    }
  });

  renderer.render(scene, camera);

  // draw mini next piece & hold
  if(piecesQueue[0]) drawMini(nextCtx, piecesQueue[0]);
  drawHold();
}

/* ---------- Controls and UI wiring ---------- */
window.addEventListener('keydown', (e)=>{
  if(!running) return;
  if(e.key === 'ArrowLeft'){ playerMove(-1); }
  else if(e.key === 'ArrowRight'){ playerMove(1); }
  else if(e.key === 'ArrowUp'){ playerRotate(1); }
  else if(e.key === 'ArrowDown'){ playerSoftDrop(); }
  else if(e.code === 'Space'){ e.preventDefault(); playerDropHard(); }
  else if(e.key === 'Shift'){ /* turbo: fast drop while held */ dropCounter = dropInterval + 1; }
  else if(e.key.toLowerCase() === 'c'){ doHold(); }
  else if(e.key.toLowerCase() === 'p'){ paused = !paused; showPause(paused); }
});

document.getElementById('btn-reset').addEventListener('click', ()=>{ restart(); });
document.getElementById('btn-ai').addEventListener('click', ()=>{
  aiMode = !aiMode;
  document.getElementById('btn-ai').innerText = `ü§ñ AI: ${aiMode ? 'On' : 'Off'}`;
});
document.getElementById('btn-music').addEventListener('click', ()=>{
  if(!music){ initAudio(); }
  musicOn = !musicOn;
  if(musicOn){ music.play(); document.getElementById('btn-music').innerText = 'üîä Music' } else { music.pause(); document.getElementById('btn-music').innerText = 'üéµ Music' }
});
document.getElementById('vol').addEventListener('input', (e)=>{
  const v = parseFloat(e.target.value);
  if(music) music.volume = v;
  [sfxClear, sfxDrop, sfxLock, sfxPower].forEach(s => { if(s) s.volume = v; });
});
document.getElementById('btn-shop').addEventListener('click', ()=>{ document.getElementById('modal-shop').style.display='block'; });
document.getElementById('close-shop').addEventListener('click', ()=>{ document.getElementById('modal-shop').style.display='none'; });
document.getElementById('btn-save').addEventListener('click', ()=>{ saveToLB(); renderLeaderboard(); });
document.getElementById('btn-clear-lb').addEventListener('click', ()=>{ localStorage.removeItem('tetris3d_lb'); renderLeaderboard(); });
document.getElementById('btn-export').addEventListener('click', ()=>{ const data = localStorage.getItem('tetris3d_lb')||'[]'; const w = window.open(''); w.document.write(`<pre>${data}</pre>`); });
document.getElementById('power-freeze').addEventListener('click', ()=>{ if(parseInt(localStorage.getItem('t3_perm_freeze')||'0',10)===1){ powerFreeze(); } else if(confirm('Gunakan 10 coins untuk freeze 5 detik?')){ if(coins>=10){ coins-=10; saveCoins(); powerFreeze(); updateHUD(); } else alert('Koin tidak cukup'); }});
document.getElementById('power-bomb').addEventListener('click', ()=>{ if(confirm('Gunakan 15 coins untuk bomb area?')){ if(coins>=15){ powerBomb(); updateHUD(); } else alert('Koin tidak cukup'); }});
document.getElementById('power-clear').addEventListener('click', ()=>{ if(confirm('Gunakan 12 coins untuk clear random?')){ if(coins>=12){ powerClearRandom(); updateHUD(); } else alert('Koin tidak cukup'); }});
document.getElementById('btn-sfx').addEventListener('click', ()=>{ sfxOn = !sfxOn; document.getElementById('btn-sfx').innerText = sfxOn ? 'üîä SFX' : 'üîï SFX'; });

/* shop buy clicks in modal */
document.getElementById('shop-items-modal').addEventListener('click', (e)=>{
  const b = e.target.closest('.btn');
  if(!b) return;
  const id = b.dataset.id;
  buyItem(id);
});

/* ---------- Audio ---------- */
function initAudio(){
  try{
    music = new Audio('https://cdn.pixabay.com/download/audio/2022/03/10/audio_d1fdf73e48.mp3?filename=retro-game-music-11077.mp3');
    music.loop = true; music.volume = parseFloat(document.getElementById('vol').value);
    sfxLock = new Audio('https://cdn.pixabay.com/download/audio/2022/03/10/audio_ke1d3f6e27.mp3?filename=ui-click-5401.mp3'); sfxLock.volume = 0.45;
    sfxClear = new Audio('https://cdn.pixabay.com/download/audio/2022/03/31/audio_9e4b05a6cd.mp3?filename=line-clear.mp3'); sfxClear.volume = 0.6;
    sfxDrop = new Audio('https://cdn.pixabay.com/download/audio/2022/03/23/audio_13b1a4f0fd.mp3?filename=small-foley-5708.mp3'); sfxDrop.volume = 0.4;
    sfxPower = new Audio('https://cdn.pixabay.com/download/audio/2022/03/24/audio_8b4d1a0a3a.mp3?filename=power-up-12403.mp3'); sfxPower.volume = 0.5;
  }catch(e){ console.warn('Audio init failed', e); }
}

/* ---------- Helpers: show overlay/modal ---------- */
function showOverlay(title, text){
  const el = document.getElementById('overlay-text');
  el.style.display = 'block'; el.innerHTML = `<div style="font-size:24px;color:${THEMES[currentTheme].accent1};font-weight:700">${title}</div><div style="margin-top:8px;color:#cfe8ff">${text}</div>`;
  setTimeout(()=>{ el.style.display = 'none'; }, 1800);
}
function showModal(title, body){
  const modal = document.getElementById('modal-help');
  modal.style.display = 'block';
  document.getElementById('modal-title').innerText = title;
  document.getElementById('modal-body').innerHTML = body;
}
document.getElementById('modal-close').addEventListener('click', ()=>{ document.getElementById('modal-help').style.display = 'none'; });

/* ---------- Theme apply ---------- */
function applyTheme(id){
  currentTheme = id;
  localStorage.setItem('t3_theme', id);
  const t = THEMES[id];
  document.documentElement.style.setProperty('--accent1', t.accent1);
  document.documentElement.style.setProperty('--accent2', t.accent2);
  if(renderer) renderer.setClearColor(t.bgColor);
}

/* ---------- Restart / Init ---------- */
function restart(){
  arena = createMatrix(COLS, ROWS);
  meshGrid = createMatrix(COLS, ROWS);
  if(activeGroup){ scene.remove(activeGroup); activeGroup = null; }
  piecesQueue = [];
  refillQueue();
  pieceIndex = 1;
  score = 0; lines = 0; level = 1; dropInterval = DROP_BASE; coins = parseInt(localStorage.getItem('t3_coins')||'0',10) || 0;
  canHold = true; holdPiece = null;
  updateHUD(); rebuildMeshGrid(); spawnPiece();
}

/* start everything */
function start(){
  renderShop();
  renderLeaderboard();
  initAudio();
  refillQueue();
  spawnPiece();
  updateHUD();
  requestAnimationFrame(update);
}
start();

/* ---------- Small initial helper calls ---------- */
function spawnPiece(){ spawnPiece = spawnPieceReal; } // placeholder to avoid hoisting confusion (this line will be ignored)
/* Re-define correct spawnPiece function (fix hoisting) */
function spawnPieceReal(){
  refillQueue();
  const mat = piecesQueue.shift();
  const id = (pieceIndex % 7) + 1;
  pieceIndex++;
  currentPiece = { matrix: mat, x: Math.floor((COLS - mat[0].length)/2), y: 0, id };
  canHold = true;
  if(activeGroup){ scene.remove(activeGroup); activeGroup = null; }
  activeGroup = createPieceGroup(currentPiece.matrix, currentPiece.id);
  placeActiveGroupAt(activeGroup, currentPiece.x, currentPiece.y);
  scene.add(activeGroup);
  drawMini(nextCtx, piecesQueue[0]);
  drawHold();
  if(collide(arena, currentPiece)){ running = false; showModal('Game Over', `Skor ${score}. Tekan Restart.`); saveHighscore(); }
}
/* overwrite with actual function */
spawnPiece = spawnPieceReal;

/* ---------- Cleanup notes / safety ---------- */
/* There were some issues that often cause bugs:
   - Keeping Three.js mesh references in sync with arena (we rebuildMeshGrid after merges)
   - Collision logic uses currentPiece.x/y and matrix bounds carefully
   - Hoisting conflicts: using function reassignments avoids wrong order
   - Avoid heavy per-frame allocations (we reuse arrays where feasible)
*/

/* ---------- Misc helpers ---------- */
function drawMini(ctx2d, matrix){
  ctx2d.clearRect(0,0,ctx2d.canvas.width,ctx2d.canvas.height);
  ctx2d.fillStyle = 'rgba(1,6,12,0.9)';
  ctx2d.fillRect(0,0,ctx2d.canvas.width,ctx2d.canvas.height);
  if(!matrix) return;
  const cell = Math.floor(Math.min(ctx2d.canvas.width/4, ctx2d.canvas.height/4) - 6);
  const w = matrix[0].length, h = matrix.length;
  const offsetX = Math.floor((4 - w)/2);
  const offsetY = Math.floor((4 - h)/2);
  for(let y=0;y<4;y++){
    for(let x=0;x<4;x++){
      const mx = x - offsetX, my = y - offsetY;
      let val = 0;
      if(my >=0 && my < h && mx >=0 && mx < w) val = matrix[my][mx];
      if(val){
        ctx2d.fillStyle = COLORS[val];
        ctx2d.fillRect(x*cell + 8, y*cell + 8, cell-6, cell-6);
        ctx2d.strokeStyle='rgba(0,0,0,0.2)';
        ctx2d.strokeRect(x*cell + 8, y*cell + 8, cell-6, cell-6);
      }
    }
  }
}

/* ---------- Final minor fixes: ensure spawn called once properly ---------- */
// ensure initial spawn
if(!currentPiece) spawnPiece();

/* ensure UI initial states */
document.getElementById('btn-ai').innerText = `ü§ñ AI: ${aiMode ? 'On' : 'Off'}`;

/* expose debug */
window.__T3 = { arena, restart, spawnPiece, scene, renderer, camera, piecesQueue, getLB };

/* Render initial frame once */
renderFrame();
</script>
</body>
</html>
