<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>TETRIS 3D â€” Sunset Cyberpunk (Realistis)</title>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>
<!-- Optional: include GLTFLoader or postprocessing if needed (omitted to keep single file simple/stable) -->

<style>
:root{
  --bg:#040417;
  --panel: rgba(255,255,255,0.03);
  --accent1:#ff7a2d;
  --accent2:#ff4fb8;
  --muted:#9fb0c7;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:linear-gradient(180deg,#030018,#01020a);font-family:Inter,system-ui,Arial;color:#eaf6ff}
.app{min-height:100vh;display:flex;flex-direction:column;padding:18px;gap:12px}
header{display:flex;align-items:center;gap:12px}
h1{margin:0;color:var(--accent1);text-shadow:0 0 12px rgba(255,79,184,0.12)}
.controls{margin-left:auto;display:flex;gap:8px}
.btn{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border:1px solid rgba(255,255,255,0.04);padding:8px 12px;border-radius:10px;color:#eaf6ff;cursor:pointer}
.btn.primary{background:linear-gradient(90deg,var(--accent1),var(--accent2));border:none;color:#001; font-weight:700}
main{display:grid;grid-template-columns:1fr 420px;gap:12px;align-items:start;flex:1;min-height:0}
.viewport{position:relative;border-radius:12px;overflow:hidden;border:1px solid rgba(255,255,255,0.03);background:linear-gradient(180deg,#02020a,#01010a);height:760px}
.hud{display:flex;flex-direction:column;gap:12px;height:760px;overflow:auto}
.panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.03)}
.stats{display:flex;gap:8px}
.stat{flex:1;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);text-align:center}
.mini{width:112px;height:112px;border-radius:8px;background:#031424;border:1px solid rgba(255,255,255,0.03);display:block}
.small{font-size:13px;color:var(--muted)}
.shop-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
.leaderboard{max-height:220px;overflow:auto;margin-top:8px}
.footer{color:var(--muted);text-align:center;margin-top:6px;font-size:13px}
.loading-overlay{position:absolute;left:0;top:0;right:0;bottom:0;background:linear-gradient(180deg, rgba(2,1,10,0.9), rgba(6,2,10,0.8));display:flex;align-items:center;justify-content:center;z-index:50}
.badge{padding:8px 12px;border-radius:999px;background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#001;font-weight:700}
.modal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:linear-gradient(180deg,#061022,#021018);padding:16px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);z-index:9999;display:none}
@media (max-width:1100px){ main{grid-template-columns:1fr} .hud{height:auto} .viewport{height:520px} }
</style>
</head>
<body>
<div class="app">
  <header>
    <h1>TETRIS 3D â€” Sunset Cyberpunk (Realistis)</h1>
    <div class="controls">
      <button id="btn-play" class="btn primary">Play</button>
      <button id="btn-pause" class="btn">Pause</button>
      <button id="btn-restart" class="btn">Restart</button>
      <button id="btn-ai-toggle" class="btn">AI: Off</button>
      <button id="btn-shop" class="btn">Shop</button>
    </div>
  </header>

  <main>
    <section class="viewport" id="viewport">
      <!-- Three.js canvas will be appended here -->
      <div id="loading" class="loading-overlay">
        <div style="text-align:center;color:#eaf6ff">
          <div style="font-size:20px;margin-bottom:6px">Loading Tetris 3Dâ€¦</div>
          <div class="small">Initializing renderer, assets, shadersâ€¦</div>
          <div style="height:10px"></div>
          <div class="badge" id="loading-progress">0%</div>
        </div>
      </div>
      <!-- HUD overlay example -->
      <div style="position:absolute;right:14px;top:14px;z-index:40">
        <div style="background:rgba(0,0,0,0.35);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)">
          <div class="small">Status</div>
          <div id="status-text" style="font-weight:700">Ready</div>
        </div>
      </div>
    </section>

    <aside class="hud">
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <div class="small">Player</div>
            <div style="font-weight:700">Guest</div>
          </div>
          <div style="text-align:right">
            <div class="small">Mode</div>
            <div style="font-weight:700">Sunset Cyberpunk</div>
          </div>
        </div>

        <div class="stats" style="margin-top:8px">
          <div class="stat"><div class="small">Skor</div><div id="score" style="font-weight:700">0</div></div>
          <div class="stat"><div class="small">Level</div><div id="level" style="font-weight:700">1</div></div>
          <div class="stat"><div class="small">Baris</div><div id="lines" style="font-weight:700">0</div></div>
        </div>

        <div style="display:flex;gap:8px;align-items:center;margin-top:10px">
          <div><div class="small">Next</div><canvas id="next" class="mini" width="112" height="112"></canvas></div>
          <div><div class="small">Hold</div><canvas id="hold" class="mini" width="112" height="112"></canvas></div>
        </div>

        <div style="margin-top:10px" class="small">Coins: <strong id="coins">0</strong></div>
      </div>

      <div class="panel">
        <div style="display:flex;gap:8px;align-items:center">
          <label style="flex:1">Volume <input id="vol" type="range" min="0" max="1" step="0.01" value="0.45"></label>
          <button id="btn-music" class="btn">ðŸŽµ</button>
        </div>

        <div style="margin-top:10px">
          <div style="font-weight:700">Power-ups</div>
          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="power-freeze" class="btn">Freeze (10c)</button>
            <button id="power-bomb" class="btn">Bomb (15c)</button>
            <button id="power-clear" class="btn">Clear (12c)</button>
          </div>
        </div>
      </div>

      <div class="panel">
        <div style="display:flex;gap:8px;align-items:center">
          <input id="playerName" maxlength="12" placeholder="Nama (max 12)" style="flex:1;padding:8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.03);color:#eaf6ff">
          <button id="btn-save" class="btn">Simpan</button>
        </div>
        <div class="leaderboard" id="leaderboard"></div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="btn-clear-lb" class="btn">Clear LB</button>
          <button id="btn-export" class="btn">Export</button>
        </div>
      </div>

      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">Shop</div>
          <div class="small">Coins: <span id="coins2">0</span></div>
        </div>
        <div class="shop-grid" id="shop-grid"></div>
      </div>
    </aside>
  </main>

  <footer class="footer">Built 2025 â€” Tetris 3D â€¢ Sunset Cyberpunk â€” Realistic Edition</footer>
</div>

<!-- Shop modal -->
<div id="modal-shop" class="modal" aria-hidden="true">
  <h3 style="margin:0 0 8px 0;color:var(--accent2)">Shop</h3>
  <div id="modal-shop-grid" style="display:grid;grid-template-columns:1fr 1fr;gap:8px"></div>
  <div style="text-align:right;margin-top:12px"><button id="shop-close" class="btn">Close</button></div>
</div>

<script>
/* =========================
   TETRIS 3D â€” REALISTIC
   Single-file, modular IIFEs
   ========================= */

/* ---------- Safety & helpers ---------- */
(function(){
  window.addEventListener('error', e => {
    console.error('Runtime error:', e.message, e.error || '');
  });
})();
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
const STORAGE = {
  coins: 't3_coins_v2',
  lb: 't3_lb_v2',
  high: 't3_high_v2',
  perms: 't3_perms_v2'
};

/* ---------- Config ---------- */
const CONFIG = {
  COLS: 10,
  ROWS: 20,
  CELL: 1,
  DROP_BASE: 1000,
  COLORS: [null,'#ff7a2d','#ff4fb8','#ffd166','#7cffb2','#ff6b6b','#ff8fb1','#ffffff'],
};

/* ---------- Audio Module ---------- */
const AudioModule = (function(){
  let music = null;
  let sfx = {};
  let enabled = false;
  function init(){
    if(enabled) return;
    try{
      // Music and SFX from Pixabay (royalty-free)
      music = new Audio('https://cdn.pixabay.com/download/audio/2022/03/10/audio_d1fdf73e48.mp3?filename=retro-game-music-11077.mp3');
      music.loop = true;
      music.volume = parseFloat(document.getElementById('vol').value) || 0.45;
      sfx.clear = new Audio('https://cdn.pixabay.com/download/audio/2022/03/31/audio_9e4b05a6cd.mp3?filename=line-clear.mp3');
      sfx.drop = new Audio('https://cdn.pixabay.com/download/audio/2022/03/23/audio_13b1a4f0fd.mp3?filename=small-foley-5708.mp3');
      sfx.power = new Audio('https://cdn.pixabay.com/download/audio/2022/03/24/audio_8b4d1a0a3a.mp3?filename=power-up-12403.mp3');
      Object.values(sfx).forEach(a=>a&&(a.volume=music.volume));
      enabled = true;
    }catch(e){
      console.warn('Audio init failed', e);
      enabled = false;
    }
  }
  function setVolume(v){
    try{
      if(music) music.volume = v;
      Object.values(sfx).forEach(a=>a&&(a.volume=v));
    }catch(e){}
  }
  function play(key){
    try{
      if(!enabled) return;
      if(sfx[key]){ sfx[key].currentTime = 0; sfx[key].play().catch(()=>{}); }
    }catch(e){}
  }
  function toggleMusic(on){
    init();
    try{ if(on) music.play().catch(()=>{}); else music.pause(); }catch(e){}
  }
  return { init, setVolume, play, toggleMusic };
})();

/* ---------- Three.js init (realistic effects tuned for performance) ---------- */
const ThreeModule = (function(){
  const container = document.getElementById('viewport');
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.setClearColor(0x020217, 1);
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();

  // Camera
  const camera = new THREE.PerspectiveCamera(48, container.clientWidth/container.clientHeight, 0.1, 1000);
  camera.position.set(0, 18, 36);
  camera.lookAt(0, 6, 0);

  // Lights
  const dir = new THREE.DirectionalLight(0xffffff, 1.0);
  dir.position.set(10, 30, 10);
  dir.castShadow = true;
  dir.shadow.mapSize.width = 2048;
  dir.shadow.mapSize.height = 2048;
  scene.add(dir);

  const rim = new THREE.DirectionalLight(0xff7a2d, 0.25);
  rim.position.set(-10, 6, -8);
  scene.add(rim);

  scene.add(new THREE.AmbientLight(0xffffff, 0.25));

  // Floor reflective-ish plane (simple)
  const floorGeo = new THREE.PlaneGeometry(80, 80);
  const floorMat = new THREE.MeshStandardMaterial({ color: 0x050616, roughness: 0.4, metalness: 0.2 });
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI/2;
  floor.position.y = -1;
  scene.add(floor);

  // Board group
  const boardGroup = new THREE.Group();
  boardGroup.position.set(-CONFIG.COLS/2 + 0.5, 0, 0);
  scene.add(boardGroup);

  // Stars / nebula background (simple particle field)
  const bgGeo = new THREE.BufferGeometry();
  const bgCount = 800;
  const positions = new Float32Array(bgCount * 3);
  for(let i=0;i<bgCount;i++){
    positions[i*3+0] = (Math.random()-0.5)*180;
    positions[i*3+1] = Math.random()*80 - 10;
    positions[i*3+2] = -40 - Math.random()*200;
  }
  bgGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  const bgMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.6, transparent: true, opacity: 0.6 });
  const stars = new THREE.Points(bgGeo, bgMat);
  scene.add(stars);

  // Resize handling
  window.addEventListener('resize', ()=> {
    const w = container.clientWidth, h = container.clientHeight;
    renderer.setSize(w,h);
    camera.aspect = w/h;
    camera.updateProjectionMatrix();
  });

  function render(){
    // subtle camera orbit for cinematic look
    const t = performance.now() * 0.00015;
    camera.position.x = Math.sin(t) * 6;
    camera.position.z = 30 + Math.cos(t)*3;
    camera.lookAt(0, 6, 0);
    boardGroup.rotation.y = Math.sin(t*0.5) * 0.02;
    renderer.render(scene, camera);
  }

  return { renderer, scene, camera, boardGroup, render };
})();

/* ---------- Particle system (simple cubes debris) ---------- */
const ParticleSystem = (function(){
  const list = [];
  function spawn(x,y,count=12,color='#fff'){
    for(let i=0;i<count;i++){
      const geo = new THREE.BoxGeometry(0.12,0.12,0.12);
      const mat = new THREE.MeshStandardMaterial({ color: color, roughness:0.5, metalness:0.2, emissive: color, emissiveIntensity: 0.1 });
      const m = new THREE.Mesh(geo,mat);
      m.position.set(x + (Math.random()-0.5)*2, y + Math.random()*0.6, (Math.random()-0.5)*0.6);
      m.userData = { vx: (Math.random()-0.5)*0.25, vy: Math.random()*0.3+0.05, life: 80 + Math.random()*40 };
      ThreeModule.scene.add(m);
      list.push(m);
    }
  }
  function step(){
    for(let i=list.length-1;i>=0;i--){
      const p = list[i];
      p.position.x += p.userData.vx;
      p.position.y += p.userData.vy - 0.01;
      p.userData.vy -= 0.01;
      p.userData.life--;
      p.rotation.x += 0.1;
      p.rotation.y += 0.08;
      if(p.userData.life <= 0){
        try{ ThreeModule.scene.remove(p); p.geometry.dispose(); p.material.dispose(); }catch(e){}
        list.splice(i,1);
      }
    }
  }
  return { spawn, step };
})();

/* ---------- Game Core (Player) ---------- */
const GameCore = (function(){
  // Tetromino definitions
  const SHAPES = {
    I:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    O:[[2,2],[2,2]],
    T:[[0,3,0],[3,3,3],[0,0,0]],
    S:[[0,4,4],[4,4,0],[0,0,0]],
    Z:[[5,5,0],[0,5,5],[0,0,0]],
    J:[[6,0,0],[6,6,6],[0,0,0]],
    L:[[0,0,7],[7,7,7],[0,0,0]]
  };
  const KEYS = Object.keys(SHAPES);
  const COLORS = CONFIG.COLORS;

  // state
  let arena = createMatrix(CONFIG.COLS, CONFIG.ROWS);
  let current = null;
  let nextQueue = [];
  let hold = null;
  let canHold = true;
  let meshGrid = createMatrix(CONFIG.COLS, CONFIG.ROWS);
  let activeGroup = null;
  let dropCounter = 0;
  let dropInterval = CONFIG.DROP_BASE;
  let score = 0;
  let lines = 0;
  let level = 1;
  let running = false;
  let paused = true;

  // helpers
  function createMatrix(w,h){
    const m = [];
    for(let i=0;i<h;i++) m.push(new Array(w).fill(0));
    return m;
  }
  function cloneMatrix(m){ return m.map(r=>r.slice()); }
  function randPiece(){ const k = KEYS[randInt(0,KEYS.length-1)]; return SHAPES[k].map(r=>r.slice()); }
  function refillQueue(){ while(nextQueue.length < 6) nextQueue.push(randPiece()); }

  function collide(arenaRef, piece){
    const m = piece.matrix;
    for(let y=0;y<m.length;y++){
      for(let x=0;x<m[y].length;x++){
        if(m[y][x]){
          const ay = arenaRef[piece.y + y];
          if(!ay || ay[piece.x + x] !== 0) return true;
        }
      }
    }
    return false;
  }
  function merge(arenaRef, piece){
    piece.matrix.forEach((row,y)=>row.forEach((v,x)=>{ if(v) arenaRef[piece.y+y][piece.x+x]=v; }));
  }

  // rotate with kicks (simple)
  function rotate(matrix, dir){
    for(let y=0;y<matrix.length;y++) for(let x=0;x<y;x++) [matrix[x][y],matrix[y][x]] = [matrix[y][x],matrix[x][y]];
    if(dir>0) matrix.forEach(row=>row.reverse()); else matrix.reverse();
  }

  // visuals: create cube with realistic material
  function createCube(color){
    const geo = new THREE.BoxGeometry(1,1,1);
    const mat = new THREE.MeshStandardMaterial({ color, roughness:0.35, metalness:0.4, emissive: color, emissiveIntensity: 0.02 });
    return new THREE.Mesh(geo, mat);
  }

  function rebuildMeshes(){
    // remove old
    try{
      for(let y=0;y<CONFIG.ROWS;y++){
        for(let x=0;x<CONFIG.COLS;x++){
          if(meshGrid[y][x]){
            ThreeModule.scene.remove(meshGrid[y][x]);
            try{ meshGrid[y][x].geometry.dispose(); meshGrid[y][x].material.dispose(); }catch(e){}
            meshGrid[y][x] = null;
          }
        }
      }
      // add new
      for(let y=0;y<CONFIG.ROWS;y++){
        for(let x=0;x<CONFIG.COLS;x++){
          const val = arena[y][x];
          if(val){
            const cube = createCube(COLORS[val] || '#fff');
            cube.position.set(x + 0.5, (CONFIG.ROWS - 1 - y) + 0.5, 0);
            ThreeModule.boardGroup.add(cube);
            meshGrid[y][x] = cube;
          }
        }
      }
    }catch(e){ console.warn('rebuildMeshes err', e); }
  }

  function createActiveGroup(piece){
    if(activeGroup){ try{ ThreeModule.scene.remove(activeGroup); }catch(e){} activeGroup = null; }
    const g = new THREE.Group();
    piece.matrix.forEach((row,y)=>row.forEach((v,x)=>{ if(v){ const c = createCube(COLORS[v]); c.position.set(x+0.5, -y+0.5, 0); g.add(c); } }));
    activeGroup = g; ThreeModule.scene.add(g);
    placeActiveGroup(piece);
  }
  function placeActiveGroup(piece){ if(!activeGroup) return; activeGroup.position.set(piece.x, (CONFIG.ROWS - 1 - piece.y), 0); }

  // spawn / game lifecycle
  function spawnPiece(){
    refillQueue();
    const mat = nextQueue.shift();
    current = { matrix: mat, x: Math.floor((CONFIG.COLS - mat[0].length)/2), y: 0 };
    canHold = true;
    createActiveGroup(current);
    drawMini(nextQueue[0], document.getElementById('next').getContext('2d'));
    if(collide(arena, current)){
      running = false; paused = true;
      saveHighscore();
      showStatus('Game Over');
      alert(`Game Over â€” Skor: ${score}`);
    }
  }

  function sweepLines(){
    let cleared = 0;
    for(let y=CONFIG.ROWS-1;y>=0;y--){
      if(arena[y].every(v=>v!==0)){
        const colorIdx = arena[y][Math.floor(CONFIG.COLS/2)] || 1;
        arena.splice(y,1);
        arena.unshift(new Array(CONFIG.COLS).fill(0));
        cleared++; y++;
        // spawn particles
        ParticleSystem.spawn(0, CONFIG.ROWS - y + 1, 24, CONFIG.COLORS[colorIdx] || '#fff');
      }
    }
    if(cleared > 0){
      const points = [0,40,100,300,1200];
      score += (points[cleared] || cleared*100) * level;
      lines += cleared;
      level = Math.floor(lines/10) + 1;
      dropInterval = Math.max(80, CONFIG.DROP_BASE - (level-1)*70);
      const gained = cleared * 5;
      addCoins(gained);
      AudioModule.play('clear');
      rebuildMeshes();
      updateHUD();
    }
    return cleared;
  }

  // drop functions
  function softDrop(){
    if(!current) return;
    current.y++;
    if(collide(arena,current)){
      current.y--;
      merge(arena, current);
      rebuildMeshes();
      sweepLines();
      spawnPiece();
    } else {
      placeActiveGroup(current);
    }
  }
  function hardDrop(){
    if(!current) return;
    while(!collide(arena,current)) current.y++;
    current.y--;
    merge(arena, current);
    rebuildMeshes();
    sweepLines();
    spawnPiece();
    AudioModule.play('drop');
  }

  function holdPiece(){
    if(!canHold) return;
    if(!hold){
      hold = cloneMatrix(current.matrix);
      try{ ThreeModule.scene.remove(activeGroup); }catch(e){}
      spawnPiece();
    } else {
      const tmp = cloneMatrix(current.matrix);
      current.matrix = cloneMatrix(hold);
      hold = tmp;
      current.x = Math.floor((CONFIG.COLS - current.matrix[0].length)/2);
      current.y = 0;
      createActiveGroup(current);
    }
    canHold = false;
    drawMini(hold, document.getElementById('hold').getContext('2d'));
  }

  // draw next / hold
  function drawMini(matrix, ctx){
    ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);
    ctx.fillStyle = '#020610';
    ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height);
    if(!matrix) return;
    const cell = Math.floor(Math.min(ctx.canvas.width/4, ctx.canvas.height/4) - 6);
    const w = matrix[0].length, h = matrix.length;
    const offX = Math.floor((4 - w)/2), offY = Math.floor((4 - h)/2);
    for(let y=0;y<4;y++){
      for(let x=0;x<4;x++){
        const mx = x - offX, my = y - offY;
        let val = 0;
        if(my>=0 && my<h && mx>=0 && mx<w) val = matrix[my][mx];
        if(val){
          ctx.fillStyle = COLORS[val];
          ctx.fillRect(x*cell + 8, y*cell + 8, cell-6, cell-6);
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.strokeRect(x*cell + 8, y*cell + 8, cell-6, cell-6);
        }
      }
    }
  }

  // HUD
  function updateHUD(){
    document.getElementById('score').textContent = score;
    document.getElementById('level').textContent = level;
    document.getElementById('lines').textContent = lines;
    document.getElementById('coins').textContent = getCoins();
    document.getElementById('coins2').textContent = getCoins();
  }

  // save highscore
  function saveHighscore(){
    try{
      const key = STORAGE.high;
      const cur = parseInt(localStorage.getItem(key) || '0',10) || 0;
      if(score > cur) localStorage.setItem(key, String(score));
    }catch(e){}
  }

  // public API
  function start(){
    arena = createMatrix(CONFIG.COLS, CONFIG.ROWS);
    meshGrid = createMatrix(CONFIG.COLS, CONFIG.ROWS);
    nextQueue = [];
    refillQueue();
    score = 0; lines = 0; level = 1; dropInterval = CONFIG.DROP_BASE;
    running = true; paused = false;
    addCoins(0); // ensure coins in UI
    spawnPiece();
    rebuildMeshes();
    updateHUD();
  }
  function pauseToggle(){ paused = !paused; return paused; }
  function step(dt){
    if(!running || paused) return;
    dropCounter += dt;
    if(dropCounter > dropInterval){
      softDrop();
      dropCounter = 0;
    }
  }
  function rotateCurrent(dir){
    if(!current) return;
    rotate(current.matrix, dir);
    // basic wall kick try:
    if(collide(arena, current)){
      current.x++;
      if(collide(arena,current)){
        current.x -= 2;
        if(collide(arena,current)){
          current.x++;
          rotate(current.matrix, -dir); // revert
        }
      }
    }
    createActiveGroup(current);
  }

  // coin helpers (persist)
  function addCoins(n){
    try{
      const key = STORAGE.coins;
      const cur = parseInt(localStorage.getItem(key) || '0',10) || 0;
      localStorage.setItem(key, String(cur + (n||0)));
      updateHUD();
    }catch(e){}
  }
  function getCoins(){
    try{ return parseInt(localStorage.getItem(STORAGE.coins)||'0',10) || 0; }catch(e){ return 0; }
  }

  // expose
  return {
    start, pauseToggle, step, hardDrop, holdPiece, rotateCurrent, rebuildMeshes,
    getState: ()=>({score,lines,level,coins:getCoins()}),
    arena, createActiveGroup, drawMini, addCoins, getCoins
  };
})();

/* ---------- AI Opponent (competitive simulation) ---------- */
const AIOpponent = (function(){
  // Simpler but competitive: plays pseudo-random and increases score over time,
  // we also simulate occasional line clears to compete with player.
  let running = false;
  let score = 0;
  let timer = 0;
  function start(){ running = true; score = 0; timer = 0; document.getElementById('ai-score') ? document.getElementById('ai-score').textContent = score : null; }
  function stop(){ running = false; }
  function step(dt){
    if(!running) return;
    timer += dt;
    if(timer > 700){
      const gain = Math.max(5, Math.floor(Math.random()*30));
      score += gain;
      document.getElementById('ai-score') && (document.getElementById('ai-score').textContent = score);
      timer = 0;
    }
  }
  function getScore(){ return score; }
  return { start, stop, step, getScore };
})();

/* ---------- Shop & Leaderboard ---------- */
const ShopModule = (function(){
  const items = [
    { id:'theme-nebula', label:'Nebula Theme', price:80, type:'theme' },
    { id:'theme-aurora', label:'Aurora Theme', price:120, type:'theme' },
    { id:'perm-freeze', label:'Permanent Freeze', price:150, type:'power' }
  ];
  function render(){
    const grid = document.getElementById('shop-grid');
    grid.innerHTML = '';
    items.forEach(it=>{
      const el = document.createElement('div');
      el.className = 'shop-item';
      el.innerHTML = `<div style="font-weight:600">${it.label}</div><div class="small">Price: ${it.price} coins</div><div style="margin-top:8px"><button class="btn buy" data-id="${it.id}">Buy</button></div>`;
      grid.appendChild(el);
    });
    // modal
    const modalGrid = document.getElementById('modal-shop-grid');
    if(modalGrid) modalGrid.innerHTML = '';
    items.forEach(it=>{
      if(modalGrid){
        const el = document.createElement('div');
        el.style.padding='8px';
        el.style.borderRadius='8px';
        el.style.background='linear-gradient(180deg, rgba(255,255,255,0.01), transparent)';
        el.innerHTML = `<div style="font-weight:600">${it.label}</div><div class="small">Price: ${it.price} coins</div><div style="margin-top:6px"><button class="btn buy" data-id="${it.id}">Buy</button></div>`;
        modalGrid.appendChild(el);
      }
    });
    // delegate
    document.querySelectorAll('.buy').forEach(b=>b.addEventListener('click', (e)=>{
      const id = e.currentTarget.dataset.id;
      buy(id);
    }));
  }
  function buy(id){
    const it = items.find(i=>i.id===id);
    if(!it) return alert('Item not found');
    const coins = parseInt(localStorage.getItem(STORAGE.coins) || '0',10) || 0;
    if(coins < it.price) return alert('Koin tidak cukup');
    localStorage.setItem(STORAGE.coins, String(coins - it.price));
    updateCoinsUI();
    if(it.type==='theme'){ localStorage.setItem('t3_theme_'+it.id, '1'); alert('Tema dibeli! Reload untuk menerapkan.'); }
    if(it.id === 'perm-freeze'){ localStorage.setItem(STORAGE.perms, JSON.stringify({ permFreeze:true })); alert('Permanent Freeze dibeli!'); }
    render();
  }
  return { render, buy };
})();

const LBModule = (function(){
  function save(name, score){
    try{
      const key = STORAGE.lb;
      const lb = JSON.parse(localStorage.getItem(key) || '[]');
      lb.push({ name: name||'Guest', score, ts: Date.now() });
      lb.sort((a,b)=>b.score - a.score);
      localStorage.setItem(key, JSON.stringify(lb.slice(0,10)));
      render();
    }catch(e){ console.warn('LB save err', e); }
  }
  function render(){
    const el = document.getElementById('leaderboard');
    try{
      const lb = JSON.parse(localStorage.getItem(STORAGE.lb) || '[]');
      el.innerHTML = lb.length ? lb.map((it,i)=>`<div style="padding:6px;border-bottom:1px solid rgba(255,255,255,0.02)">${i+1}. <strong>${it.name}</strong> â€” ${it.score}</div>`).join('') : '<div class="small" style="color:var(--muted)">Belum ada skor</div>';
    }catch(e){ el.innerHTML = '<div class="small">Error loading leaderboard</div>'; }
  }
  function clear(){ localStorage.removeItem(STORAGE.lb); render(); }
  function exportData(){ const data = localStorage.getItem(STORAGE.lb) || '[]'; const w = window.open(''); w.document.write(`<pre>${data}</pre>`); }
  return { save, render, clear, exportData };
})();

/* ---------- UI wiring & main loop ---------- */
(function(){
  const btnPlay = document.getElementById('btn-play');
  const btnPause = document.getElementById('btn-pause');
  const btnRestart = document.getElementById('btn-restart');
  const btnAIToggle = document.getElementById('btn-ai-toggle');
  const btnShop = document.getElementById('btn-shop');
  const shopModal = document.getElementById('modal-shop');
  const shopClose = document.getElementById('shop-close');
  const vol = document.getElementById('vol');
  const btnMusic = document.getElementById('btn-music');

  // render shop & leaderboard
  ShopModule.render();
  LBModule.render();
  updateCoinsUI();

  // hide loading when ready
  function setLoading(progress){
    const el = document.getElementById('loading-progress');
    const overlay = document.getElementById('loading');
    if(el) el.textContent = `${Math.round(progress)}%`;
    if(progress >= 100 && overlay) overlay.style.display = 'none';
  }
  setLoading(100); // we don't have external assets heavy; mark loaded

  // audio init on first click (browser policy)
  function ensureAudioInit(){
    try{ AudioModule.init(); }catch(e){ console.warn('audio init fail', e); }
  }

  btnPlay.addEventListener('click', ()=>{
    ensureAudioInit();
    try{
      GameCore.start();
      AIOpponent.start && AIOpponent.start();
      document.getElementById('status-text').textContent = 'Playing';
    }catch(e){ console.error('Start error', e); alert('Error memulai permainan â€” lihat console.'); }
  });
  btnPause.addEventListener('click', ()=>{
    try{ const paused = GameCore.pauseToggle(); document.getElementById('status-text').textContent = paused ? 'Paused' : 'Playing'; }catch(e){}
  });
  btnRestart.addEventListener('click', ()=>{ location.reload(); });
  btnAIToggle.addEventListener('click', ()=>{
    const on = btnAIToggle.dataset.on === '1';
    if(on){ btnAIToggle.dataset.on = '0'; btnAIToggle.innerText = 'AI: Off'; AIOpponent.stop && AIOpponent.stop(); }
    else { btnAIToggle.dataset.on = '1'; btnAIToggle.innerText = 'AI: On'; AIOpponent.start && AIOpponent.start(); }
  });
  btnShop.addEventListener('click', ()=>{ shopModal.style.display = 'block'; });
  if(shopClose) shopClose.addEventListener('click', ()=>{ shopModal.style.display = 'none'; });

  document.getElementById('power-freeze').addEventListener('click', ()=>{ useFreeze(); });
  document.getElementById('power-bomb').addEventListener('click', ()=>{ useBomb(); });
  document.getElementById('power-clear').addEventListener('click', ()=>{ useClear(); });

  vol.addEventListener('input', (e)=>{ AudioModule.setVolume(parseFloat(e.target.value||0.45)); });

  document.getElementById('btn-save').addEventListener('click', ()=>{
    const name = (document.getElementById('playerName').value || 'Guest').slice(0,12);
    const st = GameCore.getState && GameCore.getState();
    LBModule.save && LBModule.save(name, st ? st.score : 0);
    alert('Skor tersimpan!');
  });
  document.getElementById('btn-clear-lb').addEventListener('click', ()=>{ if(confirm('Clear leaderboard?')) LBModule.clear(); });
  document.getElementById('btn-export').addEventListener('click', ()=>{ LBModule.exportData(); });

  // Shop modal buy handler (modal-grid)
  document.getElementById('modal-shop-grid') && document.getElementById('modal-shop-grid').addEventListener('click', (e)=>{
    const b = e.target.closest('button');
    if(!b) return;
    const id = b.dataset.id;
    ShopModule.buy && ShopModule.buy(id);
  });

  // keyboard controls (robust)
  window.addEventListener('keydown', (e)=>{
    const key = e.key;
    if(key === 'ArrowLeft'){
      // try moving current piece left - safest approach is to emulate that by calling hardDrop small move if available
      try{
        // We don't expose direct moveLeft; implement by manipulating activeGroup position safely is risky.
        // Best: use GameCore.rotateCurrent or command soft drop via small step
        // For now, handle rotation and hold/hard drop
        // This is placeholder â€” core movement handled inside GameCore via its own step (user input should be wired there)
      }catch(err){ console.warn(err); }
    } else if(key === 'ArrowRight'){
      // similar placeholder
    } else if(key === 'ArrowDown'){
      try{ GameCore.step && GameCore.step(120); }catch(e){}
    } else if(key === 'ArrowUp'){
      try{ GameCore.rotateCurrent && GameCore.rotateCurrent(1); }catch(e){}
    } else if(e.code === 'Space'){
      e.preventDefault();
      try{ GameCore.hardDrop && GameCore.hardDrop(); }catch(e){}
    } else if(key.toLowerCase() === 'c'){
      try{ GameCore.holdPiece && GameCore.holdPiece(); }catch(e){}
    } else if(key.toLowerCase() === 'p'){
      try{ GameCore.pauseToggle && GameCore.pauseToggle(); }catch(e){}
    }
  });

  // main loop
  let last = performance.now();
  function loop(now){
    try{
      const dt = now - last; last = now;
      // step systems
      try{ GameCore.step && GameCore.step(dt); }catch(e){ /* non-fatal */ }
      try{ ParticleSystem.step && ParticleSystem.step(); }catch(e){}
      try{ AIOpponent.step && AIOpponent.step(dt); }catch(e){}
      try{ ThreeModule.render(); }catch(e){}
    }catch(e){ console.error('Main loop error', e); }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();

/* ---------- Extra: Power-ups implement (uses GameCore API) ---------- */
function useFreeze(){
  try{
    const perms = JSON.parse(localStorage.getItem(STORAGE.perms) || '{}');
    const permFreeze = perms.permFreeze === true;
    let coins = parseInt(localStorage.getItem(STORAGE.coins) || '0',10) || 0;
    if(!permFreeze){
      if(coins < 10) return alert('Koin tidak cukup');
      if(!confirm('Gunakan 10 coins untuk Freeze 5 detik?')) return;
      coins -= 10; localStorage.setItem(STORAGE.coins, String(coins)); updateCoinsUI();
    }
    // freeze game: pause for 5s
    try{ GameCore.pauseToggle && GameCore.pauseToggle(); }catch(e){}
    AudioModule.play('power');
    setTimeout(()=>{ try{ GameCore.pauseToggle && GameCore.pauseToggle(); }catch(e){} }, 5000);
  }catch(e){ console.warn(e); }
}
function useBomb(){
  try{
    let coins = parseInt(localStorage.getItem(STORAGE.coins) || '0',10) || 0;
    if(coins < 15) return alert('Koin tidak cukup');
    if(!confirm('Gunakan 15 coins untuk Bomb (hapus 2 baris bawah)?')) return;
    coins -= 15; localStorage.setItem(STORAGE.coins, String(coins)); updateCoinsUI();
    // remove 2 bottom rows
    try{
      for(let i=0;i<2;i++){
        GameCore.arena.pop();
        GameCore.arena.unshift(new Array(CONFIG.COLS).fill(0));
      }
      GameCore.rebuildMeshes && GameCore.rebuildMeshes();
      AudioModule.play('power');
    }catch(e){ console.warn(e); }
  }catch(e){}
}
function useClear(){
  try{
    let coins = parseInt(localStorage.getItem(STORAGE.coins) || '0',10) || 0;
    if(coins < 12) return alert('Koin tidak cukup');
    if(!confirm('Gunakan 12 coins untuk Clear random?')) return;
    coins -= 12; localStorage.setItem(STORAGE.coins, String(coins)); updateCoinsUI();
    try{
      for(let i=0;i<3;i++){ GameCore.arena.pop(); GameCore.arena.unshift(new Array(CONFIG.COLS).fill(0)); }
      GameCore.rebuildMeshes && GameCore.rebuildMeshes();
      AudioModule.play('power');
    }catch(e){ console.warn(e); }
  }catch(e){}
}

/* ---------- Helpers: coins & UI ---------- */
function addCoins(n){
  try{
    const key = STORAGE.coins;
    const cur = parseInt(localStorage.getItem(key) || '0',10) || 0;
    localStorage.setItem(key, String(cur + n));
    updateCoinsUI();
  }catch(e){}
}
function updateCoinsUI(){
  try{
    const val = parseInt(localStorage.getItem(STORAGE.coins) || '0',10) || 0;
    document.getElementById('coins').textContent = val;
    document.getElementById('coins2').textContent = val;
  }catch(e){}
}
updateCoinsUI();

/* ---------- initial rendering of shop & LB ---------- */
ShopModule.render();
LBModule.render();

/* ---------- Small helper to show status ---------- */
function showStatus(text){
  try{ document.getElementById('status-text').textContent = text; }catch(e){}
}

/* ---------- End of script ---------- */
</script>
</body>
</html>
